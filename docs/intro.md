# 概述
以IO多路复用为核心，采取单Reactor模式，接受处理请求和发送响应（目前仅能处理静态文件请求）。用时间堆管理的定时器来处理超时链接。



# 整体架构

采取单Reactor模式，一个主线程多个工作线程，主线程负责监听和接受链接，工作线程负责处理请求和读写任务。当fd有可读/写事件时，主线程将可调用对象放入工作队列，工作线程通过竞争条件获取任务执行。



# 多线程
用oneshot来保证一个fd一次只会被一个线程处理。
目前采用的是vector存储thread对象，线程池析构时主线程把运行条件设置为false，唤醒每个线程，然后循环join每个线程
线程间共享的数据如mutex、condition_variable，封装在一个struct里，然后用shared_ptr指向共享的数据
工作队列用一个queue存储functional可调用对象，线程间通过unique_lock来获取工作队列
## 线程池实现
参考：https://www.zhihu.com/question/27908489
这个博主是将创建线程后detach了， 这样主线程不需要join来等待子线程和存储thread，但是如果没有log的话调试起来不方便，所以我这里先改成用vector存储thread，析构时循环join每个线程

最聪明的一点是share_ptr的使用，使得即使线程detach了也不用担心工作队列...共享变量的销毁

一开始创建时每个线程会unique_lock获取锁，获取后进入循环，而后又因为条件变量而睡眠（注意这里会释放锁，这也是为什么cond.wait需要一个unique_lock参数而lock_guard不行，只有uni...可以临时释放锁又加锁）



# 定时器
采用最小堆管理定时器，堆内存储的是指向定时器的shared_ptr; 因为堆不支持随机访问，所以让httpcontext对象持有一个指针来引用定时器；

- 指针需要是weak_ptr而不能用shared_ptr因为定时器对象的生命周期应该受堆管理，需要修改定时器时再通过weak_ptr::lock()获得共享指针
- 定时器的删除采取延迟删除也就是懒删除，把定时器状态设置为删除状态，等超时了才真正从堆里删除
- 如果一个定时器被“删除了”，那么它的定时任务不应该被执行，否则会出现重复释放内存的错误



# Buffer
buffer参照muduo网络库的buffer设计，使用vector<char>实现能自动增长等待缓冲区；

## 缓冲区细节

缓冲区用两个下标划分为三个部分： 

前置空区域 	| 	已写区域 	| 	后置空区域

#######readIndex####writeIndex#####

1. 后置区域够大，直接写
2. 后置区域+前置区域够，使用copy函数复制已写部分到缓冲区原点，重置读写指针
3. 后置+前置还是不够，将vector resize

通过返回begin迭代器，转换为char\*指针*(先用\*解引用，再用&取址)*，再加上位偏移就可以得到可读/可写位置的char\*指针

## 读写操作

### 读操作

使用readv读取，除了读取到buffer外，额外添加一个65535B的栈数组，以确保能一次读完所有数据，假如读到了额外的数组里面读完后再append到buffer里即可

### 写操作

写操作用writev写，第一个iovec的base指向buffer，第二个指向一个文件。通过mmap将文件映射到内存中，避免读取到buffer的复制造成的额外的开销。 *考虑是否能用sendfile进一步改进* 