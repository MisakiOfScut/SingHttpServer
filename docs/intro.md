## 概述
以IO多路复用为核心，采取单Reactor模式，接受处理请求和发送响应（目前仅能处理静态文件请求）。用时间堆管理的定时器来处理超时链接。

## 整体架构
采取单Reactor模式，一个主线程多个工作线程，主线程负责监听和接受链接，工作线程负责处理请求和读写任务。当fd有可读/写事件时，主线程将可调用对象放入工作队列，工作线程通过竞争条件获取任务执行。

## 多线程
用oneshot来保证一个fd一次只会被一个线程处理。
目前采用的是vector存储thread对象，线程池析构时主线程把运行条件设置为false，唤醒每个线程，然后循环join每个线程
线程间共享的数据如mutex、condition_variable，封装在一个struct里，然后用shared_ptr指向共享的数据
工作队列用一个queue存储functional可调用对象，线程间通过unique_lock来获取工作队列
## 定时器
每个定时器关联一个fd，拥有一个回调对象（即定时任务）和时间戳（记录超时时间）。用一个最小堆管理定时器，依照超时时间排序，在每次处理完io事件后再处理定时任务和移除超时的定时器 *tick*。
额外用一个unordered_map记录fd和定时器之间的关联，方便更新和删除操作。
定时器的删除采取懒删除，删除不会把定时器从时间堆中移除只会把定时任务置空（避免堆重排序造成的开销），在每次tick时才会真正删除

## 读写操作
### 读操作
使用readv读取，除了读取到buffer外，额外添加一个65535B的栈数组，以确保能一次读完所有数据，假如读到了额外的数组里面读完后再append到buffer里即可
### 写操作
写操作用writev写，第一个iovec的base指向buffer，第二个指向一个文件。通过mmap将文件映射到内存中，避免读取到buffer的复制造成的额外的开销。 *考虑是否能用sendfile进一步改进* 

## Buffer
buffer参照muduo网络库的buffer设计